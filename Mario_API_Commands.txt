ðŸŽ® MARIO API COMMANDS REFERENCE
=====================================

MOVEMENT COMMANDS
-----------------
marioAPI.move(direction, steps)
- Parameters:
  * direction: "left" or "right" (string)
  * steps: Number between 1-50 (integer)
- Example: marioAPI.move("right", 10);

ACTION COMMANDS
--------------
marioAPI.jump()
- Makes Mario jump
- Example: marioAPI.jump();

marioAPI.fireball()
- Shoots a fireball (only works if Mario has fire power)
- Example: marioAPI.fireball();

DUCKING COMMANDS
----------------
marioAPI.duck()
- Makes Mario duck (only works if Mario is large)
- Example: marioAPI.duck();

marioAPI.stopDuck()
- Makes Mario stop ducking
- Example: marioAPI.stopDuck();

TIMING COMMANDS
---------------
marioAPI.wait(frames)
- Parameters:
  * frames: Number between 1-100 (integer)
- Example: marioAPI.wait(30); // Wait for 30 frames

INFORMATION COMMANDS (READ-ONLY)
--------------------------------
marioAPI.getPosition()
- Returns Mario's current position and state
- Returns: {x, y, onGround, facing}
- Also displays position in status message
- Example: let pos = marioAPI.getPosition();

marioAPI.logPosition()
- Displays Mario's position in a detailed, formatted way
- Shows position, ground status, facing direction, and timestamp
- More visual than getPosition()
- Example: marioAPI.logPosition();

marioAPI.getQueueLength()
- Returns the number of commands currently in the queue
- Example: let count = marioAPI.getQueueLength();

NOTE: These are READ-ONLY functions that don't add commands to the queue.
They execute immediately and show information about Mario's current state.

EXAMPLE USAGE:
--------------
// Check Mario's position
marioAPI.logPosition();

// Move and check again
marioAPI.move("right", 5);
marioAPI.getPosition();

// Use position in conditional logic
let pos = marioAPI.getPosition();
if (pos.x > 100) {
    marioAPI.jump();
}



IMPORTANT NOTES
===============

1. Sequential Execution: Commands execute one after another, not simultaneously
2. Power Requirements: 
   - fireball() only works if Mario has fire power
   - duck() only works if Mario is large
3. Limits:
   - move() steps: 1-50
   - wait() frames: 1-100
   - fireball() limited by screen fireball count (max 2)
4. Read-Only: getPosition() and getQueueLength() don't add commands to the queue





ADVANCED PROGRAMMING PATTERNS
=============================

// 1. CONDITIONAL LOGIC
//------------------------------------------
let pos = marioAPI.getPosition();
if (pos.x > 100) {
    marioAPI.jump();
} else {
    marioAPI.move("right", 5);
}

if (pos.onGround) {
    marioAPI.jump();
} else {
    marioAPI.move("right", 2);
}

// Check Mario's position and display it
marioAPI.logPosition();
if (marioAPI.getPosition().x > 200) {
    marioAPI.move("left", 3);
}


// 2. FUNCTION DEFINITIONS
//------------------------
function jumpAndMove(direction, steps) {
    marioAPI.jump();
    marioAPI.move(direction, steps);
}

function attackSequence() {
    marioAPI.move("right", 3);
    marioAPI.wait(10);
    marioAPI.move("right", 3);
}

jumpAndMove("right", 5);
attackSequence();


// 3. SWITCH STATEMENTS
//---------------------
let action = "jump";
switch(action) {
    case "jump":
        marioAPI.jump();
        break;
    case "move":
        marioAPI.move("right", 5);
        break;
}


// 4. ARRAYS AND ITERATION
//------------------------
let actions = [
    {type: "move", direction: "right", steps: 3},
    {type: "jump"},
    {type: "move", direction: "left", steps: 2}
];

actions.forEach(action => {
    if (action.type === "move") {
        marioAPI.move(action.direction, action.steps);
    } else if (action.type === "jump") {
        marioAPI.jump();
    }
});


// 5. OBJECT-ORIENTED PATTERNS
//----------------------------
class MarioController {
    constructor() {
        this.actions = [];
    }
    
    addMove(direction, steps) {
        this.actions.push({type: "move", direction, steps});
    }
    
    addJump() {
        this.actions.push({type: "jump"});
    }
    
    execute() {
        this.actions.forEach(action => {
            if (action.type === "move") {
                marioAPI.move(action.direction, action.steps);
            } else if (action.type === "jump") {
                marioAPI.jump();
            }
        });
    }
}

let controller = new MarioController();
controller.addMove("right", 5);
controller.addJump();
controller.addMove("left", 3);
controller.execute();


// 6. RECURSIVE FUNCTIONS
//-----------------------
function marioDance(steps) {
    if (steps > 0) {
        marioAPI.move("right", 2);
        marioAPI.move("left", 2);
        marioDance(steps - 1);
    }
}
marioDance(3);


// 7. EVENT-DRIVEN PATTERNS
//-------------------------
function reactToPosition() {
    let pos = marioAPI.getPosition();
    
    if (pos.x < 50) {
        marioAPI.move("right", 10);
    } else if (pos.x > 200) {
        marioAPI.move("left", 5);
    } else {
        marioAPI.jump();
    }
}
reactToPosition();


// 8. MATHEMATICAL PATTERNS
//-------------------------
for (let i = 0; i < 5; i++) {
    let steps = Math.floor(Math.random() * 5) + 1;
    let direction = i % 2 === 0 ? "right" : "left";
    marioAPI.move(direction, steps);
    marioAPI.jump();
}


// 9. STATE MACHINES
//------------------
let marioState = "exploring";
function updateMario() {
    switch(marioState) {
        case "exploring":
            marioAPI.move("right", 3);
            marioState = "jumping";
            break;
        case "jumping":
            marioAPI.jump();
            marioState = "exploring";
            break;
    }
}
updateMario();


// 10. ASYNC PATTERNS WITH PROMISES
//---------------------------------
function marioSequence() {
    return new Promise((resolve) => {
        marioAPI.move("right", 5);
        setTimeout(() => {
            marioAPI.jump();
            resolve();
        }, 1000);
    });
}

async function marioAdventure() {
    await marioSequence();
    marioAPI.move("left", 2);
}


// 11. STRATEGY PATTERN
//---------------------
const strategies = {
    aggressive: () => {
        marioAPI.move("right", 3);
        marioAPI.jump();
    },
    defensive: () => {
        marioAPI.move("left", 2);
    },
    exploratory: () => {
        marioAPI.move("right", 5);
        marioAPI.jump();
        marioAPI.move("left", 3);
    }
};

strategies.aggressive();


// 12. TEMPLATE METHOD PATTERN
//----------------------------
function marioActionTemplate() {
    marioAPI.move("right", 2);
    customAction();
    marioAPI.move("left", 1);
}

function customAction() {
    marioAPI.jump();
}

marioActionTemplate();


// 13. OBSERVER PATTERN
//---------------------
class MarioEventSystem {
    constructor() {
        this.listeners = {};
    }
    
    on(event, callback) {
        this.listeners[event] = callback;
    }
    
    trigger(event) {
        if (this.listeners[event]) {
            this.listeners[event]();
        }
    }
}

let events = new MarioEventSystem();
events.on("jump", () => marioAPI.jump());
events.on("move", () => marioAPI.move("right", 5));

events.trigger("jump");
events.trigger("move");


// 14. FUNCTIONAL PROGRAMMING
//---------------------------
const marioActions = {
    move: (direction, steps) => () => marioAPI.move(direction, steps),
    jump: () => () => marioAPI.jump()
};

const composedAction = () => {
    marioActions.move("right", 3)();
    marioActions.jump()();
};

composedAction();


// 15. DATA-DRIVEN PROGRAMMING
//----------------------------
const marioBehaviors = {
    "patrol": [
        {action: "move", params: ["right", 5]},
        {action: "jump"},
        {action: "move", params: ["left", 5]},
        {action: "jump"}
    ],
    "attack": [
        {action: "move", params: ["right", 2]},
        {action: "wait", params: [10]},
        {action: "move", params: ["right", 2]}
    ]
};

function executeBehavior(behaviorName) {
    const behavior = marioBehaviors[behaviorName];
    behavior.forEach(step => {
        if (step.action === "move") {
            marioAPI.move(step.params[0], step.params[1]);
        } else if (step.action === "jump") {
            marioAPI.jump();
        } else if (step.action === "wait") {
            marioAPI.wait(step.params[0]);
        }
    });
}

executeBehavior("patrol");


